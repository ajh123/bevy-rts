# Critical Codebase Review (Follow-up)

Latest commit: `170a05a7209ee97a92a2277b6ab76f214ea2540f`
Date: 08-01-2026

## Summary
This commit is a step toward *less* anti-Bevy architecture (you finally use ECS entities for objects), but the codebase still repeats the same high-impact mistakes from review A: runtime synchronous filesystem I/O for assets, linear scans for “picking” and placement checks, and a “central god plugin” that wires everything together instead of letting each feature own its resources/systems.

Net: you removed one of the worst problems (custom object storage fighting ECS), but you kept the other critical ones almost unchanged—just moved them into workspace crates.

## What Changed Since Review A

### ✅ The worst ECS fight is mostly gone
- The previous custom object storage (“ObjectWorld”-style arena with generational IDs) is no longer the main path.
- Objects are spawned as Bevy `Entity`s with components (e.g., `ObjectKind`) and manipulated via queries.

This is the right direction.

### ✅ Raycast logic is no longer inside input
- Cursor hit testing now calls into a dedicated module (`physics/raycast.rs`) instead of burying the raymarch in the input file.

### ✅ Lighting is separated
- Sun spawning is in a lighting module now, not in the camera code.

### ✅ Dependency cleanup
- `nalgebra` is gone (good). You’re consistently using `glam`.

## Critical Problems Still Present (And Still Serious)

### 1) Synchronous `std::fs` Asset I/O + Bypassing Bevy (Still Critical)
If your requirement is “support custom user content,” then runtime disk I/O is fine and expected.

The problem is *how* you’re doing it:
- Object defs are discovered by scanning directories with `std::fs::read_dir` and read via `std::fs::read_to_string`.
- GLTF bounds are computed by reading and parsing `.gltf` JSON directly from disk.
- Terrain tile types are loaded via `std::fs::read_to_string("assets/tiles.ron")`.

Why this is still unacceptable:
1. It blocks the main thread (startup stalls and/or frame hitches when you reload/expand this).
2. It hard-wires a desktop-style filesystem layout and bypasses Bevy’s asset pipeline.
3. It throws away Bevy’s caching, hot-reload patterns, and consistent error reporting.

So no, you don’t need to “eliminate runtime I/O.” You need to stop doing *synchronous* file reads and stop building a parallel asset system.

**Fix direction (compatible with user mods):**
- Load user content through `AssetServer` with custom asset types/loaders (e.g., `Ron` definitions as assets).
- If you need directory discovery (mods folder), do it in an async task and feed results back to the main world via events/resources.
- Stop parsing GLTF JSON manually at runtime. For bounds:
  - Prefer storing bounds in your `.ron` object defs (precomputed by a tool that runs on mod import/build), OR
  - Compute bounds from loaded mesh assets asynchronously after the `AssetServer` resolves the scene/meshes.

### 2) You Still Have O(N) Picking and O(N) Placement Checks
You replaced the old “loop over custom storage” with “loop over every entity,” but the complexity is the same:
- Hover detection iterates *every* object every update.
- Placement non-overlap checks also scan all existing objects.

This will still fall over as object count grows. Mouse movement shouldn’t scale linearly with world size.

**Fix direction:**
- Use a spatial index (uniform grid / hash grid) keyed by XZ to limit candidate objects.
- Or integrate a physics/broadphase solution and query by area.

### 3) “Plugin-ified” Only Superficially
You now have a `GamePlugin`, but it acts as a monolith that:
- Inserts resources owned by other crates.
- Registers other crates’ startup/update systems directly.
- Adds `DefaultPlugins` inside itself.

This keeps the same maintainability problem as review A’s `main.rs` bloat, just relocated.

Problems with this approach:
- Features can’t be enabled/disabled cleanly.
- System ordering is hard-coded via `.chain()` instead of system sets + run conditions.
- `DefaultPlugins` hidden inside `GamePlugin` makes reuse/testing/headless runs more annoying.

**Fix direction:**
- Add real feature plugins: `TerrainPlugin`, `ObjectsPlugin`, `UiPlugin`, `CameraPlugin`, `LightingPlugin`.
- Each plugin should:
  - Register its own resources.
  - Register its own systems.
  - Expose minimal public APIs (events/resources) instead of “reach into other crate types.”

### 4) Hardcoded Tool IDs and Stringly-Typed State
The UI tool system still uses string IDs like `"construct"` and `"destroy"` spread across files.

This is fragile and lazy:
- Typos become bugs.
- Refactors become search-and-pray.
- You’re using heap `String` where a compact enum/newtype would do.

**Fix direction:**
- Use an enum `ToolId { Construct, Destroy }` or a `ToolbarToolId(u32)`.
- If you insist on strings, at least centralize them as constants.

### 5) Naming Noise: `*Res` Suffix Everywhere
You still suffix resources with `Res` (`TerrainWorldRes`, `CursorHitRes`, etc.).

Bevy already expresses resource-ness with `Res<T>` and `ResMut<T>`. The suffix adds clutter without adding information.

### 6) GLTF Bounds Logic is Brittle and Wrong-Prone
Even ignoring the I/O problem, the GLTF bounds computation is a pile of assumptions:
- Only `.gltf` is supported (not `.glb`).
- It depends on accessor `min/max` being present and correct.
- It reads the default scene, then only considers the *first* root node matrix.
- It does not traverse node hierarchies and apply per-node transforms properly.

So you’re paying the cost/complexity of manual parsing, and you still don’t get reliable bounds.

## Secondary Issues (Still Worth Fixing)
- Startup uses `.expect(...)` on asset loads: fine for early prototype, but you’re baking in “crash on missing file” behavior everywhere.
- UI layout and colors are hard-coded constants, not data-driven or theme-aware.
- Some systems do too much per-frame work in a single update stage; you’ll eventually want better scheduling.

## Recommendations (Priority Order)
1. **Stop doing synchronous `std::fs` reads for content and stop bypassing Bevy’s asset system**. Keep runtime mod support, but do it via `AssetServer` + async discovery.
2. **Fix picking/placement scalability** with a simple spatial hash grid (XZ) before you add more gameplay.
3. **Convert crates into real Bevy plugins** so each feature owns its own setup/resources/systems.
4. Replace string tool IDs with an enum/newtype.
5. Rename resources to drop `Res` suffix (optional, but it will reduce noise fast).

## Bottom Line
You fixed the most embarrassing ECS violation from review A, but you still keep reimplementing core engine responsibilities (asset management and spatial queries) in the most fragile way possible. Until the `std::fs` usage and O(N) picking/placement are addressed, this codebase will stay “prototype-only” and will hurt as soon as you scale content or targets beyond desktop dev runs.
